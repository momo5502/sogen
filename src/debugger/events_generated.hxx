// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EVENTS_DEBUGGER_H_
#define FLATBUFFERS_GENERATED_EVENTS_DEBUGGER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace Debugger {

struct PauseEvent;
struct PauseEventBuilder;
struct PauseEventT;

struct RunEvent;
struct RunEventBuilder;
struct RunEventT;

struct DebugEvent;
struct DebugEventBuilder;
struct DebugEventT;

enum Event : uint8_t {
  Event_NONE = 0,
  Event_PauseEvent = 1,
  Event_RunEvent = 2,
  Event_MIN = Event_NONE,
  Event_MAX = Event_RunEvent
};

inline const Event (&EnumValuesEvent())[3] {
  static const Event values[] = {
    Event_NONE,
    Event_PauseEvent,
    Event_RunEvent
  };
  return values;
}

inline const char * const *EnumNamesEvent() {
  static const char * const names[4] = {
    "NONE",
    "PauseEvent",
    "RunEvent",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvent(Event e) {
  if (::flatbuffers::IsOutRange(e, Event_NONE, Event_RunEvent)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEvent()[index];
}

template<typename T> struct EventTraits {
  static const Event enum_value = Event_NONE;
};

template<> struct EventTraits<Debugger::PauseEvent> {
  static const Event enum_value = Event_PauseEvent;
};

template<> struct EventTraits<Debugger::RunEvent> {
  static const Event enum_value = Event_RunEvent;
};

template<typename T> struct EventUnionTraits {
  static const Event enum_value = Event_NONE;
};

template<> struct EventUnionTraits<Debugger::PauseEventT> {
  static const Event enum_value = Event_PauseEvent;
};

template<> struct EventUnionTraits<Debugger::RunEventT> {
  static const Event enum_value = Event_RunEvent;
};

struct EventUnion {
  Event type;
  void *value;

  EventUnion() : type(Event_NONE), value(nullptr) {}
  EventUnion(EventUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Event_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EventUnion(const EventUnion &);
  EventUnion &operator=(const EventUnion &u)
    { EventUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EventUnion &operator=(EventUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EventUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = EventUnionTraits<RT>::enum_value;
    if (type != Event_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Event type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Debugger::PauseEventT *AsPauseEvent() {
    return type == Event_PauseEvent ?
      reinterpret_cast<Debugger::PauseEventT *>(value) : nullptr;
  }
  const Debugger::PauseEventT *AsPauseEvent() const {
    return type == Event_PauseEvent ?
      reinterpret_cast<const Debugger::PauseEventT *>(value) : nullptr;
  }
  Debugger::RunEventT *AsRunEvent() {
    return type == Event_RunEvent ?
      reinterpret_cast<Debugger::RunEventT *>(value) : nullptr;
  }
  const Debugger::RunEventT *AsRunEvent() const {
    return type == Event_RunEvent ?
      reinterpret_cast<const Debugger::RunEventT *>(value) : nullptr;
  }
};

bool VerifyEvent(::flatbuffers::Verifier &verifier, const void *obj, Event type);
bool VerifyEventVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct PauseEventT : public ::flatbuffers::NativeTable {
  typedef PauseEvent TableType;
};

struct PauseEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PauseEventT NativeTableType;
  typedef PauseEventBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PauseEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PauseEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PauseEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PauseEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PauseEventBuilder {
  typedef PauseEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PauseEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PauseEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PauseEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PauseEvent> CreatePauseEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PauseEventBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<PauseEvent> CreatePauseEvent(::flatbuffers::FlatBufferBuilder &_fbb, const PauseEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RunEventT : public ::flatbuffers::NativeTable {
  typedef RunEvent TableType;
  bool single_step = false;
};

struct RunEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RunEventT NativeTableType;
  typedef RunEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SINGLE_STEP = 4
  };
  bool single_step() const {
    return GetField<uint8_t>(VT_SINGLE_STEP, 0) != 0;
  }
  bool mutate_single_step(bool _single_step = 0) {
    return SetField<uint8_t>(VT_SINGLE_STEP, static_cast<uint8_t>(_single_step), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SINGLE_STEP, 1) &&
           verifier.EndTable();
  }
  RunEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RunEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RunEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RunEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RunEventBuilder {
  typedef RunEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_single_step(bool single_step) {
    fbb_.AddElement<uint8_t>(RunEvent::VT_SINGLE_STEP, static_cast<uint8_t>(single_step), 0);
  }
  explicit RunEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RunEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RunEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RunEvent> CreateRunEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool single_step = false) {
  RunEventBuilder builder_(_fbb);
  builder_.add_single_step(single_step);
  return builder_.Finish();
}

::flatbuffers::Offset<RunEvent> CreateRunEvent(::flatbuffers::FlatBufferBuilder &_fbb, const RunEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugEventT : public ::flatbuffers::NativeTable {
  typedef DebugEvent TableType;
  Debugger::EventUnion event{};
};

struct DebugEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DebugEventT NativeTableType;
  typedef DebugEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  Debugger::Event event_type() const {
    return static_cast<Debugger::Event>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const Debugger::PauseEvent *event_as_PauseEvent() const {
    return event_type() == Debugger::Event_PauseEvent ? static_cast<const Debugger::PauseEvent *>(event()) : nullptr;
  }
  const Debugger::RunEvent *event_as_RunEvent() const {
    return event_type() == Debugger::Event_RunEvent ? static_cast<const Debugger::RunEvent *>(event()) : nullptr;
  }
  void *mutable_event() {
    return GetPointer<void *>(VT_EVENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyEvent(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  DebugEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DebugEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Debugger::PauseEvent *DebugEvent::event_as<Debugger::PauseEvent>() const {
  return event_as_PauseEvent();
}

template<> inline const Debugger::RunEvent *DebugEvent::event_as<Debugger::RunEvent>() const {
  return event_as_RunEvent();
}

struct DebugEventBuilder {
  typedef DebugEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(Debugger::Event event_type) {
    fbb_.AddElement<uint8_t>(DebugEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(::flatbuffers::Offset<void> event) {
    fbb_.AddOffset(DebugEvent::VT_EVENT, event);
  }
  explicit DebugEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DebugEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DebugEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DebugEvent> CreateDebugEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Debugger::Event event_type = Debugger::Event_NONE,
    ::flatbuffers::Offset<void> event = 0) {
  DebugEventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

::flatbuffers::Offset<DebugEvent> CreateDebugEvent(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PauseEventT *PauseEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PauseEventT>(new PauseEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PauseEvent::UnPackTo(PauseEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<PauseEvent> PauseEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PauseEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePauseEvent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PauseEvent> CreatePauseEvent(::flatbuffers::FlatBufferBuilder &_fbb, const PauseEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PauseEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return Debugger::CreatePauseEvent(
      _fbb);
}

inline RunEventT *RunEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RunEventT>(new RunEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RunEvent::UnPackTo(RunEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = single_step(); _o->single_step = _e; }
}

inline ::flatbuffers::Offset<RunEvent> RunEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RunEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRunEvent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RunEvent> CreateRunEvent(::flatbuffers::FlatBufferBuilder &_fbb, const RunEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RunEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _single_step = _o->single_step;
  return Debugger::CreateRunEvent(
      _fbb,
      _single_step);
}

inline DebugEventT *DebugEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DebugEventT>(new DebugEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugEvent::UnPackTo(DebugEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = event_type(); _o->event.type = _e; }
  { auto _e = event(); if (_e) _o->event.value = Debugger::EventUnion::UnPack(_e, event_type(), _resolver); }
}

inline ::flatbuffers::Offset<DebugEvent> DebugEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugEvent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DebugEvent> CreateDebugEvent(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DebugEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return Debugger::CreateDebugEvent(
      _fbb,
      _event_type,
      _event);
}

inline bool VerifyEvent(::flatbuffers::Verifier &verifier, const void *obj, Event type) {
  switch (type) {
    case Event_NONE: {
      return true;
    }
    case Event_PauseEvent: {
      auto ptr = reinterpret_cast<const Debugger::PauseEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_RunEvent: {
      auto ptr = reinterpret_cast<const Debugger::RunEvent *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEventVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvent(
        verifier,  values->Get(i), types->GetEnum<Event>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EventUnion::UnPack(const void *obj, Event type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Event_PauseEvent: {
      auto ptr = reinterpret_cast<const Debugger::PauseEvent *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_RunEvent: {
      auto ptr = reinterpret_cast<const Debugger::RunEvent *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> EventUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Event_PauseEvent: {
      auto ptr = reinterpret_cast<const Debugger::PauseEventT *>(value);
      return CreatePauseEvent(_fbb, ptr, _rehasher).Union();
    }
    case Event_RunEvent: {
      auto ptr = reinterpret_cast<const Debugger::RunEventT *>(value);
      return CreateRunEvent(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline EventUnion::EventUnion(const EventUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Event_PauseEvent: {
      value = new Debugger::PauseEventT(*reinterpret_cast<Debugger::PauseEventT *>(u.value));
      break;
    }
    case Event_RunEvent: {
      value = new Debugger::RunEventT(*reinterpret_cast<Debugger::RunEventT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EventUnion::Reset() {
  switch (type) {
    case Event_PauseEvent: {
      auto ptr = reinterpret_cast<Debugger::PauseEventT *>(value);
      delete ptr;
      break;
    }
    case Event_RunEvent: {
      auto ptr = reinterpret_cast<Debugger::RunEventT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Event_NONE;
}

inline const Debugger::DebugEvent *GetDebugEvent(const void *buf) {
  return ::flatbuffers::GetRoot<Debugger::DebugEvent>(buf);
}

inline const Debugger::DebugEvent *GetSizePrefixedDebugEvent(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Debugger::DebugEvent>(buf);
}

inline DebugEvent *GetMutableDebugEvent(void *buf) {
  return ::flatbuffers::GetMutableRoot<DebugEvent>(buf);
}

inline Debugger::DebugEvent *GetMutableSizePrefixedDebugEvent(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Debugger::DebugEvent>(buf);
}

inline bool VerifyDebugEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Debugger::DebugEvent>(nullptr);
}

inline bool VerifySizePrefixedDebugEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Debugger::DebugEvent>(nullptr);
}

inline void FinishDebugEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Debugger::DebugEvent> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDebugEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Debugger::DebugEvent> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Debugger::DebugEventT> UnPackDebugEvent(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Debugger::DebugEventT>(GetDebugEvent(buf)->UnPack(res));
}

inline std::unique_ptr<Debugger::DebugEventT> UnPackSizePrefixedDebugEvent(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Debugger::DebugEventT>(GetSizePrefixedDebugEvent(buf)->UnPack(res));
}

}  // namespace Debugger

#endif  // FLATBUFFERS_GENERATED_EVENTS_DEBUGGER_H_
